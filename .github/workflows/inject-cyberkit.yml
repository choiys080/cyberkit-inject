name: Inject CyberKit into IPA

on:
  workflow_dispatch:
    inputs:
      ipa_url:
        description: 'Direct download URL for decrypted browser IPA'
        required: true
        type: string
      cyberkit_tag:
        description: 'CyberKit release tag (e.g., v0.0.9-alpha)'
        required: true
        default: 'v0.0.9-alpha'
        type: string
      output_name:
        description: 'Output IPA filename (without extension)'
        required: false
        default: 'Browser-CyberKit'
        type: string

jobs:
  inject:
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          brew install ldid
          echo "âœ“ ldid installed"

      - name: Download CyberKit release
        run: |
          echo "ðŸ“¦ Fetching CyberKit ${{ inputs.cyberkit_tag }}..."

          # Try API first, fall back to direct URL
          RELEASE_URL="https://api.github.com/repos/CyberKitGroup/CyberKit/releases/tags/${{ inputs.cyberkit_tag }}"
          echo "Trying API: $RELEASE_URL"

          RELEASE_JSON=$(curl -sL "$RELEASE_URL")
          ASSETS=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".tipa")) | .browser_download_url' 2>/dev/null | head -1)

          if [ -z "$ASSETS" ] || [ "$ASSETS" = "null" ]; then
            echo "âš ï¸ API failed or no .tipa found, trying direct download..."
            # Fallback: try known release patterns
            DIRECT_URL="https://github.com/CyberKitGroup/CyberKit/releases/download/${{ inputs.cyberkit_tag }}/com.matthewbenedict.mobileminibrowser15_0.0.9-alpha.tipa"
            echo "Trying: $DIRECT_URL"
            curl -L -o cyberkit.tipa "$DIRECT_URL" || {
              # Try iOS 16 version
              DIRECT_URL="https://github.com/CyberKitGroup/CyberKit/releases/download/${{ inputs.cyberkit_tag }}/com.matthewbenedict.mobileminibrowser16_0.0.9-alpha.tipa"
              echo "Trying: $DIRECT_URL"
              curl -L -o cyberkit.tipa "$DIRECT_URL"
            }
          else
            echo "â¬‡ï¸ Downloading via API: $ASSETS"
            curl -L -o cyberkit.tipa "$ASSETS"
          fi

          # Verify download
          if [ ! -f cyberkit.tipa ] || [ ! -s cyberkit.tipa ]; then
            echo "âŒ Failed to download CyberKit tipa"
            exit 1
          fi

          echo "âœ“ Downloaded CyberKit tipa ($(ls -lh cyberkit.tipa | awk '{print $5}'))"

          # Extract CyberKit frameworks
          mkdir -p cyberkit_extract
          unzip -q cyberkit.tipa -d cyberkit_extract

          # Find the .app and copy frameworks
          CYBERKIT_APP=$(find cyberkit_extract/Payload -name "*.app" -type d | head -1)
          mkdir -p cyberkit_frameworks

          # Copy all frameworks except the browser-specific one
          for fw in "$CYBERKIT_APP/Frameworks"/*; do
            basename_fw=$(basename "$fw")
            if [[ "$basename_fw" != "MobileMiniBrowser.framework" ]]; then
              cp -R "$fw" cyberkit_frameworks/
              echo "  âœ“ Copied $basename_fw"
            fi
          done

          echo "âœ“ CyberKit frameworks extracted"

      - name: Download target IPA
        run: |
          echo "ðŸ“¦ Downloading target IPA..."
          curl -L -o target.ipa "${{ inputs.ipa_url }}"

          # Extract IPA
          mkdir -p target_extract
          unzip -q target.ipa -d target_extract

          # Find the .app directory
          TARGET_APP=$(find target_extract/Payload -name "*.app" -type d | head -1)
          echo "TARGET_APP=$TARGET_APP" >> $GITHUB_ENV

          # Get the executable name (same as .app name without extension)
          APP_NAME=$(basename "$TARGET_APP" .app)
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV

          echo "âœ“ Target IPA extracted: $APP_NAME"

      - name: Patch load commands
        run: |
          echo "ðŸ”§ Patching load commands..."

          TARGET_APP="${{ env.TARGET_APP }}"
          APP_NAME="${{ env.APP_NAME }}"

          # Find the main executable
          EXECUTABLE="$TARGET_APP/$APP_NAME"

          if [ ! -f "$EXECUTABLE" ]; then
            # Try to find it in case name differs
            EXECUTABLE=$(find "$TARGET_APP" -maxdepth 1 -type f -perm +111 | head -1)
          fi

          echo "  Executable: $EXECUTABLE"

          # Check for WebKit dependency and patch it
          if otool -L "$EXECUTABLE" | grep -q "/System/Library/Frameworks/WebKit.framework"; then
            echo "  âœ“ Found WebKit dependency, patching..."
            install_name_tool -change \
              /System/Library/Frameworks/WebKit.framework/WebKit \
              @rpath/WebKit.framework/WebKit \
              "$EXECUTABLE"
          fi

          # Also check for JavaScriptCore if needed
          if otool -L "$EXECUTABLE" | grep -q "/System/Library/Frameworks/JavaScriptCore.framework"; then
            echo "  âœ“ Found JavaScriptCore dependency, patching..."
            install_name_tool -change \
              /System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore \
              @rpath/JavaScriptCore.framework/JavaScriptCore \
              "$EXECUTABLE"
          fi

          # Patch any frameworks in the app that also depend on WebKit
          if [ -d "$TARGET_APP/Frameworks" ]; then
            for fw in "$TARGET_APP/Frameworks"/*.framework; do
              if [ -d "$fw" ]; then
                fwname=$(basename "$fw" .framework)
                fwbin="$fw/$fwname"
                if [ -f "$fwbin" ]; then
                  if otool -L "$fwbin" 2>/dev/null | grep -q "/System/Library/Frameworks/WebKit.framework"; then
                    echo "  âœ“ Patching framework: $fwname"
                    install_name_tool -change \
                      /System/Library/Frameworks/WebKit.framework/WebKit \
                      @rpath/WebKit.framework/WebKit \
                      "$fwbin"
                  fi
                fi
              fi
            done
          fi

          echo "âœ“ Load commands patched"

      - name: Copy CyberKit frameworks
        run: |
          echo "ðŸ“ Copying CyberKit frameworks..."

          TARGET_APP="${{ env.TARGET_APP }}"
          mkdir -p "$TARGET_APP/Frameworks"

          for fw in cyberkit_frameworks/*; do
            cp -R "$fw" "$TARGET_APP/Frameworks/"
            echo "  âœ“ Copied $(basename $fw)"
          done

          echo "âœ“ Frameworks copied"

      - name: Remove problematic symlinks
        run: |
          echo "ðŸ”— Removing problematic symlinks from XPC services..."

          TARGET_APP="${{ env.TARGET_APP }}"

          # Find and remove all symlinks inside XPCServices directories
          # These symlinks (pointing to ../../../../Frameworks) break ldid on TrollStore
          find "$TARGET_APP/Frameworks" -type l -name "Frameworks" -delete 2>/dev/null || true

          # Also remove any broken symlinks
          find "$TARGET_APP/Frameworks" -xtype l -delete 2>/dev/null || true

          # Remove _CodeSignature directories (TrollStore will re-sign)
          find "$TARGET_APP" -type d -name "_CodeSignature" -exec rm -rf {} + 2>/dev/null || true

          echo "âœ“ Symlinks and old signatures removed"

      - name: Create entitlements file
        run: |
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>platform-application</key>
              <true/>
              <key>com.apple.private.security.no-sandbox</key>
              <true/>
              <key>com.apple.private.mobileinstall.allowedSPI</key>
              <array>
                  <string>Lookup</string>
                  <string>Install</string>
                  <string>Browse</string>
                  <string>Uninstall</string>
                  <string>LookupForLaunchServices</string>
                  <string>InstallForLaunchServices</string>
                  <string>BrowseForLaunchServices</string>
                  <string>UninstallForLaunchServices</string>
                  <string>UpdatePlaceholder</string>
                  <string>InstallLocalProvisioned</string>
                  <string>RemoveInactivePaths</string>
              </array>
              <key>com.apple.private.persona-mgmt</key>
              <true/>
              <key>com.apple.private.security.storage.AppBundles</key>
              <true/>
          </dict>
          </plist>
          EOF
          echo "âœ“ Entitlements file created"

      - name: Strip existing signatures (TrollStore will re-sign)
        run: |
          echo "ðŸ” Stripping existing signatures..."

          TARGET_APP="${{ env.TARGET_APP }}"

          # Remove all _CodeSignature directories
          find "$TARGET_APP" -type d -name "_CodeSignature" -exec rm -rf {} + 2>/dev/null || true

          # Remove any embedded.mobileprovision files
          find "$TARGET_APP" -name "embedded.mobileprovision" -delete 2>/dev/null || true

          # Use codesign to strip signatures from all binaries (if available)
          # If not, ldid with empty signature
          strip_signature() {
            local bin="$1"
            codesign --remove-signature "$bin" 2>/dev/null || ldid -S "$bin" 2>/dev/null || true
          }

          # Strip main executable
          APP_NAME="${{ env.APP_NAME }}"
          if [ -f "$TARGET_APP/$APP_NAME" ]; then
            strip_signature "$TARGET_APP/$APP_NAME"
            echo "  âœ“ Stripped: $APP_NAME"
          fi

          # Strip frameworks
          if [ -d "$TARGET_APP/Frameworks" ]; then
            for fw in "$TARGET_APP/Frameworks"/*.framework; do
              if [ -d "$fw" ]; then
                fwname=$(basename "$fw" .framework)
                if [ -f "$fw/$fwname" ]; then
                  strip_signature "$fw/$fwname"
                  echo "  âœ“ Stripped: $fwname.framework"
                fi
              fi
            done

            # Strip dylibs
            for dylib in "$TARGET_APP/Frameworks"/*.dylib; do
              if [ -f "$dylib" ]; then
                strip_signature "$dylib"
                echo "  âœ“ Stripped: $(basename $dylib)"
              fi
            done
          fi

          echo "âœ“ Signatures stripped - TrollStore will re-sign"


      - name: Package IPA
        run: |
          echo "ðŸ“¦ Packaging final IPA..."

          cd target_extract

          # Remove any .DS_Store files
          find . -name ".DS_Store" -delete

          # Create the final .tipa
          zip -r -y "../${{ inputs.output_name }}.tipa" Payload

          cd ..
          echo "âœ“ Created ${{ inputs.output_name }}.tipa"
          ls -lh "${{ inputs.output_name }}.tipa"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.output_name }}
          path: ${{ inputs.output_name }}.tipa
          retention-days: 7

      - name: Summary
        run: |
          echo "## ðŸŽ‰ CyberKit Injection Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Source IPA**: ${{ inputs.ipa_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **CyberKit Version**: ${{ inputs.cyberkit_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Output**: ${{ inputs.output_name }}.tipa" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Download the artifact and install via TrollStore!" >> $GITHUB_STEP_SUMMARY
